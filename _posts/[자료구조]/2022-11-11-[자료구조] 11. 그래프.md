---
layout: post
author: jnr
use_math : true
published: true
categories: study
tags: data-structure graph DFS BFS
---

---
<h2 id="top"></h2><br>
📝 윤성우, 『윤성우의 열혈 자료구조:C언어를 이용한 자료구조 학습서』, 오렌지미디어, 2012. <br><br>

## 그래프
그래프 관련 용어 <br>
- 정점(vertex): 연결 대상이 되는 개체 또는 위치
- 간선(edge): 정점 사이의 연결
- 무방향 그래프(undirected graph): 연결 관계에 있어서 방향성이 없는 그래프
- 방향 그래프(directed graph): 간선에 방향정보가 포함된 그래프
- 완전 그래프(complete graph): 각각의 정점에서 다른 모든 정점을 연결한 그래프
- 가중치 그래프(weight graph): 간선에 가중치 정보(거리, 시간 등)를 둔 그래프
- 부분 그래프(sub graph): 원래 그래프의 일부 정점 및 간선으로 이루어진 그래프 <br><br>

그래프는 정점과 간선의 집합으로 표현할 수 있음. <br>
- 그래프 G의 정점 집합: V(G) = {A, B, C}
- 그래프 G의 간선 집합: E(G) = {(A, B), (A, C), (B, C)}
- 무방향 그래프에서 정점 A와 B를 연결하는 간선: (A, B) = (B, A)
- 방향 그래프에서 정점 A가 C를 가리키는 간선: <A, C> <br><br>

그래프의 ADT <br>
- void GraphInit(UALGraph *pg, int nv): 그래프 초기화. nv는 정점의 수를 전달하는 인자.
- void GraphDestroy(UALGraph *pg): 그래프 초기화 과정에서 할당한 리소스 반환.
- void AddEdge(UALGraph *pg, int fromV, int toV): 매개변수 fromV와 toV로 전달된 정점을 연결하는 간선을 그래프에 추가.
- void ShowGraphEdgeInfo(UALGraph *pg): 그래프의 간선정보 출력 <br><br>

그래프는 정방 행렬(가로세로 길이가 같은 2차원 행렬) 또는 연결 리스트로 구현이 가능. 행렬에서는 정점이 연결되어 있으면 1, 아니면 0으로 표시하며 무방향 그래프는 대각선을 기준으로 대칭을 이룸. <br><br>

```
void GraphInit(UALGraph *pg, int nv)
{
  int i;
  pg->adjList = (List *)malloc(sizeof(List)*nv); // 간선정보 저장할 리스트 생성
  pg->numV = nv; // 정점 수는 nv
  pg->numE = 0; // 간선 수는 0으로 초기화
  for(i=0; i<nv; i++) // 정점 수만큼 리스트 초기화
  {
    ListInit(&(pg->adjList[i]));
    SetSortRule(&(pg->adjList[i]), WhoIsPrecede);
  }
}

void GraphDestroy(UALGraph *pg)
{
  if(pg->adjList != NULL)
    free(pg->adjList);
}

void AddEdge(UALGraph *pg, int fromV, int toV)
{
  LInsert(&(pg->adjList[fromV]), toV);
  LInsert(&(pg->adjList[toV]), fromV);
  pg->numE += 1;
}

void ShowGraphEdgeInfo(UALGraph *pg)
{
  int i, vx;
  for(i=0; i<pg->numV; i++)
  {
    printf("%c와 연결될 정점: ", i+65);
    if(LFirst(&(pg->adjList[i]), &vx))
    {
      printf("%c ", vx+65);
      while(LNext(&(pg->adjList[i]), &vx))
        printf("%c ", vx+65);
    }
    printf("\n");
  }
}
```
<br>

그래프의 탐색은 그 어떤 자료구조보다도 복잡한 편인데, 이는 정점의 구성 뿐 아니라 간선의 연결에도 규칙이 존재하지 않기 때문. 그래프의 모든 정점을 돌아다니기 위한 알고리즘은 크게 두 가지가 있음. <br>
- 깊이 우선 탐색(DFS, Depth First Search)
- 너비 우선 탐색(BFS, Breadth First Search) <br><br>

DFS는 여러 갈래의 길에서 한 길을 깊이 파고드는 방식. 누구를 우선 선택할 것인지는 원하는 대로 결정 가능. DFS의 핵심 규칙은 다음과 같음. <br>
- 한 정점으로만 이동
- 이동할 정점이 없으면 이전 정점으로 돌아감
- 시작 정점으로 돌아가면 종료 <br><br>

DFS 구현을 위해서는 경로 정보 추적(왔던 길을 되돌아가기)을 위한 스택, 방문 정보 기록을 위한 배열이 필요. <br><br>

![Fig. 1](images/2022-11-11-1.png) <center>Fig. 1: DFS</center> <br>

```
void DFShowGraphVertex(ALGraph *pg, int startV) // 그래프 정점 정보 출력
{
  Stack stack;
  int visitV = startV;
  int nextV;
  StackInit(&stack); // DFS를 위한 스택 초기화
  VisitVertex(pg, visitV); // 시작 정점 방문
  SPush(&stack, visitV); // 시작 정점 정보를 스택
  while(LFirst(&(pg->adjList[visitV]), &nextV) == TRUE) // visitV에 담긴 정점과 연결된 정점의 방문 시도
  {
    int visitFlag = FALSE;
    if(VisitVertex(pg, nextV) == TRUE) // 방문에 성공하면
    {
      SPush(&stack, visitV); // visitV의 정보를 push
      visitV = nextV;
      visitFlag = TRUE;
    }
    else // 방문에 성공하지 못하면 연결된 다른 정점 찾기
    {
      while(LNext(&(pg->adjList[visitV]), &nextV) == TRUE)
      {
        if(VisitVertex(pg, nextV) == TRUE)
        {
          SPush(&stack, visitV);
          visitV = nextV;
          visitFlag = TRUE;
          break;
        }
      }
    }
    if(visitFlag == FALSE) // 추가로 방문한 정점이 없으면
    {
      if(SIsEmpty(&stack) == TRUE) // 시작점으로 되돌아옴
        break;
      else // 길을 되돌아감
        visitV = SPop(&stack);
    }
  }
  memset(pg->visitInfo, 0, sizeof(int)*pg->numV); // 이후의 탐색을 위해 정보 
}

int VisitVertex(ALGraph *pg, int visitV) // 정점의 방문 진행
{
  if(pg->visitInfo[visitV] == 0) // visitV에 처음 방문하면
  {
    pg->visitInfo[visitV] = 1;
    printf("%c ", visitV+65);
    return TRUE;
  }
  return FALSE;
}
```
<br>

BFS는 한 정점에서 연결된 모든 정점을 탐색하는 방식. BFS 구현을 위해서는 다음 방문 차례 기록을 위한 큐, 방문 정보 기록을 위한 배열이 필요. <br><br>

![Fig. 2](images/2022-11-11-2.png) <center>Fig. 2: BFS</center> <br>

```
void BFShowGraphVertex(ALGraph *pg, int startV) // 그래프 정점 정보 출력
{
  Queue queue;
  int visitV = startV;
  int nextV;
  QueueInit(&queue);
  VisitVertex(pg, visitV); // 시작 정점 탐색
  while(LFirst(&(pg->adjList[visit]), &nextV) == TRUE) // visitV와 연결된 모든 정점에 방문
  {
    if(VisitVertex(pg, nextV) == TRUE)
      Enqueue(&queue, nextV); // nextV에 방문했으니 큐에 저장
    while(LNext(&(pg->adjList[visitV]), &nextV) == TRUE)
    {
      if(VisitVertex(pg, nextV) == TRUE)
        Enqueue(&queue, nextV); // nextV에 방문했으니 큐에 저장
    }
    if(QIsEmpty(&queue) == TRUE) // 큐가 비면 종료
      break;
    else
      visitV = Dequeue(&queue); // 큐에서 하나 꺼내어 while문 다시 시작
  }
  memset(pg->visitInfo, 0, sizeof(int)*pg->numV); // 탐색 정보 초기화
}
```
<br>

## 최소 비용 신장 트리
사실 트리는 그래프의 한 유형. 두 개의 정점을 잇는 간선을 순서대로 나열한 것을 `경로`라고 하는데, 동일한 간선을 중복하여 포함하지 않는 경로를 `단순 경로`라고 함. 그리고 단순 경로이면서 시작과 끝이 같은 경로를 `사이클`이라고 부름. 
















```
void BSTInsert(BTreeNode **pRoot, BSTData data) // 데이터 삽입
{
  BTreeNode *pNode = NULL; // parent node
  BTreeNode *cNode = *pRoot; // current node
  BTreeNode *nNode = NULL; // new node
  while(cNode != NULL)
  {
    if(data == GetData(cNode)) // 데이터 중복을 허용하지 않음
      return;
    pNode = cNode;
    if(GetData(cNode) > data)
      cNode = GetLeftSubTree(cNode);
    else
      cNode = GetRightSubTree(cNode);
  }
  nNode = MakeBTreeNode(); // 새 노드 생성
  SetData(nNode, data); // 새 노드에 데이터 저장
  if(pNode != NULL) // 새 노드가 루트 노드가 아니면
  {
    if(data < GetData(pNode))
      MakeLeftSubTree(pNode, nNode);
    else
      MakeRightSubTree(pNode, nNode);
  }
  else // 새 노드가 루트 노드라면
    *pRoot = nNode;
}

BTreeNode *BSTSearch(BTreeNode *bst, BSTData targer) // 데이터 탐색
{
  BTreeNode *cNode = bst; // current node
  BSTData cd; // current data
  while(cNode != NULL)
  {
    cd = GetData(cNode);
    if(target == cd)
      return cNode;
    else if(target < cd)
      cNode = GetLeftSubTree(cNode);
    else
      cNode = GetRightSubTree(cNode);
  }
  return NULL; // 탐색대상이 저장되어 있지 않음
}
```
<br>

이진 탐색 트리의 삭제는 단순하지 않음. 임의의 노드를 삭제하는 경우, 삭제 후에도 이진 탐색 트리가 유지되도록 빈 자리를 채워야 함. 삭제할 노드의 경우의 수는 다음과 같음. <br>
1. 단말 노드인 경우
2. 하나의 자식 노드(하나의 서브 트리)를 갖는 경우
3. 두 개의 자식 노드(두 개의 서브 트리)를 갖는 경우 <br><br>

1은 노드를 단순히 삭제, 2는 부모 노드와 자식 노드를 연결하면 해결됨. 3의 경우, 삭제할 노드의 왼쪽 서브 트리에서 가장 큰 값이나, 삭제할 노드의 오른쪽 서브 트리에서 가장 작은 값을 저장항 노드로 대체해야 함(여기서는 오른쪽 서브 트리를 선택하기로 정하자). 가장 큰 값을 찾을 때는 NULL을 만날 때까지 계속 오른쪽 자식 노드로, 가장 작은 값을 찾을 때는 NULL을 만날 때까지 계속 왼쪽 자식 노드로 이동. <br><br>

```
void ChangeLeftSubTree(BTreeNode *main, BTreeNode *sub) { main->left = sub; } // 메모리의 소멸을 수반하지 않고 main의 왼쪽 자식 노드를 변경

void ChangeRightSubTree(BTreeNode *main, BTreeNode *sub) {  main->right = sub;  } // 메모리의 소멸을 수반하지 않고 main의 오른쪽 자식 노드를 변경

BTreeNode *RemoveLeftSubTree(BTreeNode *bt) // 왼쪽 자식 노드를 트리에서 제거한 뒤, 제거한 노드의 주소값 반환
{
  BTreeNode *delNode;
  if(bt != NULL)
  {
    delNode = bt->left;
    bt->left = NULL;
  }
  return delNode;
}

BTreeNode *RemoveRightSubTree(BTreeNode *bt)  // 오른쪽 자식 노드를 트리에서 제거한 뒤, 제거한 노드의 주소값 반환
{
  BTreeNode *delNode;
  if(bt != NULL)
  {
    delNode = bt->right;
    bt->right = NULL;
  }
  return delNode;
}

BTreeNode *BSTRemove(BTreeNode **pRoot, BSTData target)
{
  BTreeNode *pVRoot = MakeBTreeNode(); // 가상 루트 노드
  BTreeNode *pNode = pVRoot; // parent node
  BTreeNode *cNode = *pRoot; // current node
  BTreeNode *dNode; // delete node
  ChangeRightSubTree(pVRoot, *pRoot); // 루트 노드를 pVRoot가 가리키는 노드의 오른쪽 자식 노드가 되게 함
  while(cNode!=NULL && GetData(cNode)!=target) // 삭제 대상인 노드 탐색
  {
    pNode = cNode;
    if(target < GetData(cNode))
      cNode = GetLeftSubTree(cNode);
    else
      cNode = GetRightSubTree(cNode);
  }
  if(cNode == NULL) // 삭제 대상이 존재하지 않으면
    return NULL;
  dNode = cNode; // 삭제 대상을 dNode가 가리키게 함
  if(GetLeftSubTree(dNode)==NULL && GetRightSubTree(dNode)==NULL) // 1. 삭제 대상이 단말 노드인 경우
  {
    if(GetLeftSubTree(pNode) == dNode)
      RemoveLeftSubTree(pNode);
    else
      REmoveRightSubTree(pNode);
  }
  else if(GetLeftSubTree(dNode)==NULL || GetRightSubTree(dNode)==NULL) // 2. 하나의 자식 노드를 갖는 경우
  {
    BTreeNode *dcNode; // 삭제 대상의 자식 노드를 가리킴
    if(GetLeftSubTree(dNode) != NULL)
      dcNode = GetLeftSubTree(dNode);
    else
      dcNode = GetRigtSubTree(dNode);
    if(GetLeftSubTree(pNode) == dNode)
      ChangeLeftSubTree(pNode, dcNode);
    else
      ChangeRightSubTree(pNode, dcNode);
  }
  else // 3. 두 개의 자식 노드를 갖는 경우
  {
    BTreeNode *mNode = GetRightSubTree(dNode); // 대체 노드를 가리킴
    BTreeNode *mpNode = dNode; // 대체 노드의 부모 노드를 가리킴
    int delData;
    while(GetLeftSubTree(mNode) != NULL) // 삭제 대상의 대체 노드를 찾음
    {
      mpNode = mNode;
      mNode = GetLeftSubTree(mNode);
    }
    delData = GetData(dNode); // 대입 전 데이터 백업
    SetData(dNode, GetData(mNode)); // 대체 노드에 저장된 값을 삭제할 노드에 대입
    if(GetLeftSubTree(mpNode) == mNode) // 대체 노드의 부모 노드와 자식 노드를 연결
      ChangeLeftSubTree(mpNode, GetRightSubTree(mNode));
    else
      ChangeRightSubTree(mpNode, GetRightSubTree(mNode));
    dNode = mNode;
    SetData(dNode, delData); // 백업 데이터 복원
  }
  if(GetRightSubTree(pVRoot) != *pRoot)
    *pRoot = GetRightSubTree(pVRoot); // 루트 노드의 변경을 반영
  free(pVRoot); // 가상 루트 노드의 소멸
  return dNode; // 삭제 대상의 반환
}
```
<br>

## AVL 트리
데이터 저장 순서에 따라 탐색의 성능에 큰 차이를 보인다는 이진 탐색 트리의 단점을 개선한 `균형 잡인 이진 트리` 중 하나. 노드가 추가/삭제될 때, 트리의 균형상태를 스스로 파악해서 구조를 변경하고 균형을 잡음(`리밸런싱`). 트리의 균형 정도를 표현하는 `균형 인수`는 (왼쪽 서브 트리의 높이) - (오른쪽 서브 트리의 높이)로 계산됨. 리밸런싱은 균형 인수의 절댓값이 2 이상인 경우에 진행됨. <br><br>

AVL 트리의 균형이 무너지는 4가지 상태 및 해소 <br>
1. LL상태 - LL회전(LL상태에서 균형을 잡기 위해 필요한 회전)[^1]
2. RR상태 - RR회전[^2]
3. LR상태 - LR회전(RR회전으로 LL상태로 만든 다음 LL회전)[^3]
4. RL상태 - RL회전[^4] <br><br>

![Fig. 1](images/2022-11-04-1.png) <center>Fig. 1: LL회전</center> <br>
![Fig. 2](images/2022-11-04-2.png) <center>Fig. 2: RR회전</center> <br>
![Fig. 3](images/2022-11-04-3.png) <center>Fig. 3: LR회전</center> <br>
![Fig. 4](images/2022-11-04-4.png) <center>Fig. 4: RL회전</center> <br>

이전의 이진 탐색 트리 코드를 활용하여 구현(리밸런싱 기능 추가). AVL 트리는 만족스러운 성능을 보이지만, 탐색 키의 비교 과정을 거치면서 찾는 대상에 가까워지기 때문에 원하는 바를 단번에 찾지는 못함. 시간 복잡도는 $O(log_2{n})$. <br>

```
int GetHeight(BTreeNode *bst) // 트리의 높이 반환
{
  int leftH, rightH;
  if(bst == NULL)
    return 0;
  leftH = GetHeight(GetLeftSubTree(bst));
  rightH = GetHeight(GetRightSubTree(bst));
  if(leftH > rightH)
    return leftH + 1;
  else
    return rightH + 1;
}

int GetHeightDiff(BTreeNode *bst) // 두 서브 트리의 높이 차(균형 인수) 반환
{
  int lsh, rsh;
  if(bst == NULL)
    return 0;
  lsh = GetHeight(GetLeftSubTree(bst));
  rsh = GetHeight(GetRightSubTree(bst));
  return lsh-rsh;
}

BTreeNode *RotateLL(BTreeNode *bst) // LL회전
{
  BTreeNode *pNode; // parent node
  BTreeNode *cNode; // child node
  pNode = bst;
  cNode = GetLeftSubTree(pNode);
  ChangeLeftSubTree(pNode, GetRightSubTree(cNode)); // LL회전
  ChangeRightSubTree(cNode, pNode); // LL회전
  return cNode; // LL회전으로 변경된 루트 노드의 주소값 반환
}

BTreeNode *RotateRR(BTreeNode *bst) // RR회전
{
  BTreeNode *pNode; // parent node
  BTreeNode *cNode; // child node
  pNode = bst;
  cNode = GetRightSubTree(pNode);
  ChangeRightSubTree(pNode, GetLeftSubTree(cNode)); // RR회전
  ChangeLeftSubTree(cNode, pNode); // Rr회전
  return cNode; // RR회전으로 변경된 루트 노드의 주소값 반환
}

BTreeNode *RotateLR(BTreeNode *bst) // LR회전
{
  BTreeNode *pNode; // parent node
  BTreeNode *cNode; // child node
  pNode = bst;
  cNode = GetLeftSubTree(pNode);
  ChangeLeftSubTree(pNode, RotateRR(cNode)); // 부분 RR회전
  return RotateLL(pNode); // LL회전
}

BTreeNode *RotateRL(BTreeNode *bst) // RL회전
{
  BTreeNode *pNode; // parent node
  BTreeNode *cNode; // child node
  pNode = bst;
  cNode = GetRightSubTree(pNode);
  ChangeRightSubTree(pNode, RotateLL(cNode)); // 부분 LL회전
  return RotateRR(pNode); // RR회전
}

BTreeNode *Rebalance(BTreeNode **pRoot) // 리밸런싱
{
  int hDiff = GetHeightDiff(*pRoot); // 균형인수 계산
  if(hDiff > 1)
  {
    if(GetHeightDiff(GetLeftSubTree(*pRoot)) > 0) // 노드의 균형인수가 0보다 
      *pRoot = RotateLL(*pRoot);
    else
      *pRoot = RotateLR(*pRoot);
  }
  if(hDiff < -1)
  {
    if(GetHeightDiff(GetRightSubTree(*pRoot)) < 0)
      *pRoot = RotateRR(*pRoot);
    else
      *pRoot = RotateRL(*pRoot);
  }
  return *pRoot;
}
```

[`Top`](#top)

---
[^1]: [Fig. 1 link](https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html)
[^2]: [Fig. 2 link](https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html)
