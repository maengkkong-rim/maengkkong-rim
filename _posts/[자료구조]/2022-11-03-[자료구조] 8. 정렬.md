---
layout: post
author: jnr
use_math : true
published: true
categories: study
tags: data-structure sorting bubble-sort selection-sort heap-sort merge-sort quick-sort
---

---
<h2 id="top"></h2><br>
ğŸ“ ìœ¤ì„±ìš°, ã€ìœ¤ì„±ìš°ì˜ ì—´í˜ˆ ìë£Œêµ¬ì¡°:Cì–¸ì–´ë¥¼ ì´ìš©í•œ ìë£Œêµ¬ì¡° í•™ìŠµì„œã€, ì˜¤ë Œì§€ë¯¸ë””ì–´, 2012. <br><br>

## ë²„ë¸” ì •ë ¬(Bubble sort)
`ì¸ì ‘í•œ ë‘ ê°œì˜ ë°ì´í„°ë¥¼ ë¹„êµ`í•´ê°€ë©´ì„œ ì •ë ¬ì„ ì§„í–‰í•˜ëŠ” ë°©ì‹. ì •ë ¬ì˜ ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë‚®ì€, ì œì¼ í° ê°’ì„ ë§¨ ë’¤ë¡œ ë³´ëƒ„.[^1] <br>
ì´ë•Œ, ë¹„êµ/ì´ë™ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(n^2)$. <br><br>

![Fig. 1](images/2022-11-03-1.png) <center>Fig. 1: ë²„ë¸” ì •ë ¬</center> <br>

```
void BubbleSort(int arr[], int n)
{
  int i, j;
  int temp;
  for(i=0; i<n-1; i++)
  {
    for(j=0; j<(n-i)-1; j++)
    {
      if(arr[j] > arr[j+1])
      {
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
}
```
<br>

## ì„ íƒ ì •ë ¬(Selection sort)
ì •ë ¬ ìˆœì„œì— ë§ê²Œ `í•˜ë‚˜ì”© ì„ íƒí•´ì„œ ì˜®ê¸°ëŠ”` ë°©ì‹. ì •ë ¬ ìˆœì„œìƒ `ê°€ì¥ ì•ì„œëŠ” ê²ƒ`ì„ ì„ íƒí•´ì„œ ê°€ì¥ ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê³ , ì›ë˜ ìˆë˜ ë°ì´í„°ëŠ” ë¹ˆìë¦¬ë¡œ ì˜®ê¹€.[^2] <br>
ì´ë•Œ, ë¹„êµ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(n^2)$, ì´ë™ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(n)$. ë²„ë¸” ì •ë ¬ê³¼ ì„±ëŠ¥ìƒ í° ì°¨ì´ê°€ ì—†ìŒ. <br><br>

![Fig. 2](images/2022-11-03-2.PNG) <center>Fig. 2: ì„ íƒ ì •ë ¬</center> <br>

```
void SelSort(int arr[], int n)
{
  int i, j;
  int maxIdx;
  int temp;
  for(i=0; i<n-1; i++)
  {
    maxIdx = i;
    for(j=i+1; j<n; j++)
    {
      if(arr[j] < arr[maxIdx])
        maxIdx = j;
    }
    temp = arr[i];
    arr[i] = arr[maxIdx];
    arr[maxIdx] = temp;
  }
}
```
<br>

## ì‚½ì… ì •ë ¬(Insertion sort)
ì •ë ¬ì´ ë˜ì–´ìˆì§€ ì•Šì€ ë¶€ë¶„ì˜ ë°ì´í„°ë¥¼ `ì •ë ¬ëœ ë¶€ë¶„`ì˜ íŠ¹ì • ìœ„ì¹˜ì— `ì‚½ì…`í•˜ëŠ” ë°©ì‹. ì •ë ¬ëœ ë¶€ë¶„ì˜ ë°ì´í„°ë¥¼ í•œ ì¹¸ì”© ë’¤ë¡œ ë°€ë©´ì„œ ì‚½ì…í•  ìœ„ì¹˜ë¥¼ ì°¾ìŒ.[^3] <br>
ì´ë•Œ, ë¹„êµ/ì´ë™ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(n^2)$. <br><br>

![Fig. 3-1](images/2022-11-03-3-1.png) 
![Fig. 3-2](images/2022-11-03-3-2.png) 
![Fig. 3-3](images/2022-11-03-3-3.png) <center>Fig. 3: ì‚½ì… ì •ë ¬</center> <br>

```
void InserSort(int arr[], int n)
{
  int i, j;
  int insData;
  for(i=1; i<n; i++)
  {
    insData = arr[i];
    for(j=i-1; j>=0; j--)
    {
      if(arr[j] > insData)
        arr[j+1] = arr[j];
      else
        break;
    }
    arr[j+1] = insData;
  }
}
```
<br>

## í™ ì •ë ¬(Heap sort)
í™ì˜ ë£¨íŠ¸ ë…¸ë“œì— ì €ì¥ëœ ê°’ì´ ì •ë ¬ìˆœì„œìƒ ê°€ì¥ ì•ì„¬. 7. ìš°ì„ ìˆœìœ„ íì™€ í™ì—ì„œ ì •ì˜í•œ í™ì˜ í•¨ìˆ˜ ì‚¬ìš©. <br>
ì´ë•Œ, ì‚½ì…/ì‚­ì œ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(log_2{n})$, ì •ë ¬ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(n*log_2{n})$. <br><br>

```
int PriComp(int n1, int n2) { return n2-n1; } // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

void HeapSort(int arr[], int n, PriorityComp pc)
{
  Heap heap;
  int i;
  HeapInit(&heap, pc);
  for(i=0; i<n; i++)
    HInsert(&heap, arr[i]); // í™ì„ êµ¬ì„±í•œ ë’¤
  for(i=0; i<n; i++)
    arr[i] = HDelete(&heap); // ìˆœì„œëŒ€ë¡œ í•˜ë‚˜ì”© êº¼ë‚´ì„œ ì •ë ¬ ì™„ì„±
}
```
<br>

## ë³‘í•© ì •ë ¬(Merge sort)
ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜(divide and conquer - í•´ê²°ì´ ìš©ì´í•œ ë‹¨ê³„ê¹Œì§€ ë¬¸ì œë¥¼ ë¶„í• í•˜ì—¬ í•´ê²°í•œ ë’¤, ê·¸ ê²°ê³¼ë¥¼ ê²°í•©í•˜ì—¬ ë§ˆë¬´ë¦¬)ì„ ê¸°ë°˜ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ì •ë ¬. ë°ì´í„°ê°€ 1ê°œë§Œ ë‚¨ì„ ë•Œê¹Œì§€ ë¶„í• í•œ ë’¤(ì¬ê·€ì  êµ¬í˜„ì„ ìœ„í•´), ë‚˜ëˆˆ ê²ƒì„ ë³‘í•©í•˜ëŠ” ê³¼ì •ì—ì„œ ì •ë ¬ì´ ì´ë£¨ì–´ì§.[^4] <br>
ì •ë ¬ì˜ ëŒ€ìƒì„ ê³„ì†í•´ì„œ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë•Œë¬¸ì—, ì •ë ¬ì˜ ë²”ìœ„ë¥¼ ì§€ì •í•  ìˆ˜ ìˆì–´ì•¼ í•¨. ë³‘í•© ì •ë ¬ì€ ì„ì‹œ ë©”ëª¨ë¦¬ê°€ í•„ìš”ë‹¤í•˜ëŠ” ë‹¨ì ì´ ìˆì§€ë§Œ, ë°°ì—´ì´ ì•„ë‹Œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í˜„í•œë‹¤ë©´ ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŒ. <br>
ì´ë•Œ, ë¹„êµ/ì´ë™ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” $O(n*log_2{n})$. <br><br>

![Fig. 4](images/2022-11-03-4.PNG) <center>Fig. 4: ë³‘í•© ì •ë ¬</center> <br>

```
void MergeTwoArea(int arr[], int left, int mid, int right) // ì •ë ¬ëœ ë‘ ë°°ì—´ì„ ë³‘í•©
{
  int fIdx = left;
  int rIdx = mid+1;
  int i;
  int *sortArr = (int*)malloc(sizeof(int)*(right+1)); // ë³‘í•© ê²°ê³¼ë¥¼ ë‹´ì„ ë°°ì—´
  int sIdx = left;
  while(fIdx<=mid && rIdx<=right) // ë³‘í•©í•  ë‘ ì˜ì—­ì˜ ë°ì´í„°ë“¤ì„ ë¹„êµí•˜ì—¬, ì •ë ¬ ìˆœì„œëŒ€ë¡œ ë°°ì—´ì— ì˜®ê¸°ê¸°
  {
    if(arr[fIdx] <= arr[rIdx]) // ë‘ ë©ì–´ë¦¬ì˜ ì•ë¶€ë¶„ë¶€í„° í•˜ë‚˜ì”© ë¹„êµí•˜ì—¬ ì‘ì€ ê²ƒë¶€í„° ì˜®ê¸°ê¸°
      sortArr[sIdx] = arr[fIdx++];
    else
      sortArr[sIdx] = arr[rIdx++];
    sIdx++;
  }
  if(fIdx >mid) // ë°°ì—´ì˜ ì•ë¶€ë¶„ì´ ëª¨ë‘ ì˜®ê²¨ì¡Œë‹¤ë©´
  {
    for(i=rIdx; i<=right; i++, sIdx++) // ë‚¨ì€ ë’·ë¶€ë¶„ì„ ê·¸ëŒ€ë¡œ ì˜®ê¸°ê¸°
      sortArr[sIdx] = arr[i];
  }
  else // ë°°ì—´ì˜ ë’·ë¶€ë¶„ì´ ëª¨ë‘ ì˜®ê²¨ì¡Œë‹¤ë©´
  {
    for(i=fIdx; i<=mid; i++, sIdx++) // ë‚¨ì€ ì•ë¶€ë¶„ ê·¸ëŒ€ë¡œ ì˜®ê¸°ê¸°
      sortArr[sIdx] = arr[i];
  }
  for(i=left; i<=right; i++)
    arr[i] = sortArr[i];
  free(sortArr);
}

void MergeSort(int arr[], int left, int right)
{
  int mid;
  if(left < right)
  {
    mid = (left+right)/2; // ì¤‘ê°„ ì§€ì  ê³„ì‚°
    MergeSort(arr, left, mid); // ë‘˜ë¡œ ë‚˜ëˆ ì„œ ê°ê° ì •ë ¬
    MergeSort(arr, mid+1, right);
    MergeTwoArea(arr, left, mid, right); // ì •ë ¬ëœ ë‘ ë°°ì—´ ë³‘í•©
  }
}
```
<br>

## í€µ ì •ë ¬(Quick sort)






[`Top`](#top)
---
[^1]: [Fig. 1 link](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)
[^2]: [Fig. 2 link](https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html)
[^3]: [Fig. 3 link](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)
[^4]: [Fig. 4 link](https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html)
