---
layout: post
author: jnr
use_math : true
published: true
categories: study
tags: data-structure sorting bubble-sort selection-sort heap-sort merge-sort
---

---
<h2 id="top"></h2><br>
📝 윤성우, 『윤성우의 열혈 자료구조:C언어를 이용한 자료구조 학습서』, 오렌지미디어, 2012. <br><br>

## 버블 정렬(Bubble sort)
`인접한 두 개의 데이터를 비교`해가면서 정렬을 진행하는 방식. 정렬의 우선순위가 가장 낮은, 제일 큰 값을 맨 뒤로 보냄.[^1] <br>
이때, 비교/이동 연산의 시간 복잡도는 $O(n^2)$. <br><br>

![Fig. 1](images/2022-11-03-1.png) <center>Fig. 1: 버블 정렬</center> <br>

```
void BubbleSort(int arr[], int n)
{
  int i, j;
  int temp;
  for(i=0; i<n-1; i++)
  {
    for(j=0; j<(n-i)-1; j++)
    {
      if(arr[j] > arr[j+1])
      {
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
}
```
<br>

## 선택 정렬(Selection sort)
정렬 순서에 맞게 `하나씩 선택해서 옮기는` 방식. 정렬 순서상 `가장 앞서는 것`을 선택해서 가장 왼쪽으로 이동시키고, 원래 있던 데이터는 빈자리로 옮김.[^2] <br>
이때, 비교 연산의 시간 복잡도는 $O(n^2)$, 이동 연산의 시간 복잡도는 $O(n)$. 버블 정렬과 성능상 큰 차이가 없음. <br><br>

![Fig. 2](images/2022-11-03-2.PNG) <center>Fig. 2: 선택 정렬</center> <br>

```
void SelSort(int arr[], int n)
{
  int i, j;
  int maxIdx;
  int temp;
  for(i=0; i<n-1; i++)
  {
    maxIdx = i;
    for(j=i+1; j<n; j++)
    {
      if(arr[j] < arr[maxIdx])
        maxIdx = j;
    }
    temp = arr[i];
    arr[i] = arr[maxIdx];
    arr[maxIdx] = temp;
  }
}
```
<br>

## 삽입 정렬(Insertion sort)
정렬이 되어있지 않은 부분의 데이터를 `정렬된 부분`의 특정 위치에 `삽입`하는 방식. 정렬된 부분의 데이터를 한 칸씩 뒤로 밀면서 삽입할 위치를 찾음.[^3] <br>
이때, 비교/이동 연산의 시간 복잡도는 $O(n^2)$. <br><br>

![Fig. 3-1](images/2022-11-03-3-1.png) 
![Fig. 3-2](images/2022-11-03-3-2.png) 
![Fig. 3-3](images/2022-11-03-3-3.png) <center>Fig. 3: 삽입 정렬</center> <br>

```
void InserSort(int arr[], int n)
{
  int i, j;
  int insData;
  for(i=1; i<n; i++)
  {
    insData = arr[i];
    for(j=i-1; j>=0; j--)
    {
      if(arr[j] > insData)
        arr[j+1] = arr[j];
      else
        break;
    }
    arr[j+1] = insData;
  }
}
```
<br>

## 힙 정렬(Heap sort)
힙의 루트 노드에 저장된 값이 정렬순서상 가장 앞섬. 7. 우선순위 큐와 힙에서 정의한 힙의 함수 사용. <br>
이때, 삽입/삭제 연산의 시간 복잡도는 $O(log_2{n})$, 정렬 연산의 시간 복잡도는 $O(n*log_2{n})$. <br><br>

```
int PriComp(int n1, int n2) { return n2-n1; } // 오름차순 정렬

void HeapSort(int arr[], int n, PriorityComp pc)
{
  Heap heap;
  int i;
  HeapInit(&heap, pc);
  for(i=0; i<n; i++)
    HInsert(&heap, arr[i]); // 힙을 구성한 뒤
  for(i=0; i<n; i++)
    arr[i] = HDelete(&heap); // 순서대로 하나씩 꺼내서 정렬 완성
}
```
<br>

## 병합 정렬(Merge sort)
분할 정복 알고리즘(divide and conquer - 해결이 용이한 단계까지 문제를 분할하여 해결한 뒤, 그 결과를 결합하여 마무리)을 기반으로 만들어진 정렬. 데이터가 1개만 남을 때까지 분할한 뒤(재귀적 구현을 위해), 나눈 것을 병합하는 과정에서 정렬이 이루어짐. 정렬의 대상을 계속해서 반으로 나누기 때문에, 정렬의 범위를 지정할 수 있어야 함. <br><br>

![Fig. 4](images/2022-11-03-4.PNG) <center>Fig. 4: 병합 정렬</center> <br>

```
void MergeTwoArea(int arr[], int left, int mid, int right) // 정렬된 두 배열을 병합
{
  int fIdx = left;
  int rIdx = mid+1;
  int i;
  int *sortArr = (int*)malloc(sizeof(int)*(right+1));
  int sIdx = left;
  while(fIdx<=mid && rIdx<=right)
  {
    if(arr[fIdx] <= arr[rIdx])
      sortArr[sIdx] = arr[fIdx++];
    else
      sortArr[sIdx] = arr[rIdx++];
    sIdx++;
  }
  if(fIdx >mid)
  {
    for(i=rIdx; i<=right; i++, sIdx++)
      sortArr[sIdx] = arr[i];
  }
  else
  {
    for(i=fIdx; i<=mid; i++, sIdx++)
      sortArr[sIdx] = arr[i];
  }
  for(i=left; i<=right; i++)
    arr[i] = sortArr[i];
  free(sortArr);
}

void MergeSort(int arr[], int left, int right)
{
  int mid;
  if(left < right)
  {
    mid = (left+right)/2; // 중간 지점 계산
    MergeSort(arr, left, mid); // 둘로 나눠서 각각 정렬
    MergeSort(arr, mid+1, right);
    MergeTwoArea(arr, left, mid, right); // 정렬된 두 배열 병합
  }
}
```

[`Top`](#top)
---
[^1]: [Fig. 1 link](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)
[^2]: [Fig. 2 link](https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html)
[^3]: [Fig. 3 link](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)
