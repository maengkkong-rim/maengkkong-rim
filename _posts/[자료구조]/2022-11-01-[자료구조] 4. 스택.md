---
layout: post
author: jnr
use_math : true
published: true
categories: study
tags: data-structure
---

---
<h2 id="top"></h2><br>
📝 윤성우, 『윤성우의 열혈 자료구조:C언어를 이용한 자료구조 학습서』, 오렌지미디어, 2012. <br><br>

## 스택(Stack)
리스트와 더불어 스택 또한 선형 자료구조의 일종. 먼저 들어간 것이 나중에 나오는 후입선출 방식의 자료구조(LIFO-Last in, First out). 배열 기반 또는 연결 리스트 기반으로 구현이 가능함. <br><br>

스택의 ADT <br>
- void StackInit(Stack *pstack): 스택 초기화.
- int SIsEmpty(Stack *pstack): 스택이 비었으면 TRUE(1), 그렇지 않으면 FALSE(0)을 반환.
- void SPush(Stack *pstack, Data data): 스택에 데이터를 저장.
- Data SPop(Stack *pstack): 마지막에 저장된 요소 삭제 후, 삭제된 데이터 반환. 위 함수 호출을 위해서는 데이터가 하나 이상 존재해야 함.
- Data SPeek(Stack *pstack): 마지막에 저장된 요소를 반환하되 삭제하지는 않음. 위 함수 호출을 위해서는 데이터가 하나 이상 존재해야 함. <br><br>

## 스택의 배열 기반 구현
스택의 바닥을 배열의 인덱스 0으로 정의. 마지막에 저장된 데이터 위치를 별도로 기억해야 push/pop 연산을 하기 쉬움. <br>

```
void ListInit(List *plist)
{
  (plist->numOfData) = 0;
  (plist->curPosition) = -1;
}

void LInsert(List *plist, LData data)
{
  if(plist->numOfData >= LIST_LEN)
  {
    puts("저장 불가");
    return;
  }  
  plist->arr[plist->numOfData] = data;
  (plist->numOfData)++;

int LFirst(List *plist, LData *pdata)
{
  if(plist->numOfData == 0)
    return FALSE;
  (plist->curPosition) = 0; // 참조 위치 첫 번째 데이터로 초기화
  *pdata = plist->arr[0];
  return TRUE;
}

int LNext(List *plist, LData *pdata)
{
  if(plist->curPosition >= (plist->numOfData)-1) // 더 이상 참조할 데이터가 없다면
    return FALSE;
  (plist->curPositioin)++;
  *pdata = plist->arr[plist->curPosition];
  return TRUE;
}

LData LRemove(List *plist)
{
  int rpos = plist->curPosition;
  int num = plist->numOfData;
  int i;
  LData rdata = plist->arr[rpos];
  for(i=rpos; i<num-1; i++)
    plist->arr[i] = plist->arr[i+1];
  (plist->numOfData)--;
  (plist->curPosition)--;
  return rdata;
}

int LCount(List *plist)
{ return plist->numOfData;  }
```
<br>

[`Top`](#top)
