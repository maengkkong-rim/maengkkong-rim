---
layout: post
author: jnr
use_math : true
published: true
categories: study
tags: data-structure
---

---
<h2 id="top"></h2><br>
📝 윤성우, 『윤성우의 열혈 자료구조:C언어를 이용한 자료구조 학습서』, 오렌지미디어, 2012. <br><br>

## 스택(Stack)
리스트와 더불어 스택 또한 선형 자료구조의 일종. 먼저 들어간 것이 나중에 나오는 `후입선출` 방식의 자료구조(LIFO-Last in, First out). 배열 기반 또는 연결 리스트 기반으로 구현이 가능함. <br><br>

스택의 ADT <br>
- void StackInit(Stack *pstack): 스택 초기화.
- int SIsEmpty(Stack *pstack): 스택이 비었으면 TRUE(1), 그렇지 않으면 FALSE(0)을 반환.
- void SPush(Stack *pstack, Data data): 스택에 데이터를 저장.
- Data SPop(Stack *pstack): 마지막에 저장된 요소 삭제 후, 삭제된 데이터 반환. 위 함수 호출을 위해서는 데이터가 하나 이상 존재해야 함.
- Data SPeek(Stack *pstack): 마지막에 저장된 요소를 반환하되 삭제하지는 않음. 위 함수 호출을 위해서는 데이터가 하나 이상 존재해야 함. <br><br>

## 스택의 배열 기반 구현
스택의 바닥을 배열의 인덱스 0으로 정의. 마지막에 저장된 데이터 위치를 별도로 기억해야 push/pop 연산을 하기 쉬움. <br><br>

```
void StackInit(Stack *pstack) { pstack->topIndex = -1; // -1은 빈 상태를 의미  }

int SIsEmpty(Stack *pstack)
{
  if(pstack->topIndex == -1)
    return TRUE;
  else
    return FALSE;
}

void SPush(Stack *pstack, Data data)
{
  pstack->topIndex += 1;
  pstack->stackArr[pstack->topIndex] = data;
}

Data SPop(Stack *pstack)
{
  int rIdx;
  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!");
    exit(-1);
  }
  rIdx = pstack->topIndex;
  pstack->topIndex -= 1;
  return pstack->stackArr[rIdx];
}

Data SPeek(Stack *pstack)
{
  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!");
    exit(-1);
  }
  return pstack->stackArr[rIdx];
}
```
<br>

## 스택의 연결  기반 구현
```
void StackInit(Stack *pstack) { pstack->head = NULL;  }

int SIsEmpty(Stack *pstack)
{
  if(pstack->head == NULL)
    return TRUE;
  else
    return FALSE;
}

void SPush(Stack *pstack, Data data)
{
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode->data = data;
  newNode->next = pstack->head;
  pstack->head = newNode; // head에 새로운 노드 추가
}

Data SPop(Stack *pstack)
{
  Data rdata;
  Node *rnode;
  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!");
    exit(-1);
  }
  rdata = pstack->head->data;
  rnode = pstack->head;
  pstack->head = pstack->head->next;
  free(rnode);
  return rdata;
}

Data SPeek(Stack *pstack)
{
  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!");
    exit(-1);
  }
  return pstack->head->data;
}
```
<br>

## 스택을 활용한 계산기 프로그램 구현
구현에 필요한 알고리즘을 위해 우선 수식의 표기법을 살펴보려 함. 수식 표기에는 아래와 같은 3가지 방법이 있음. <br>
- 중위 표기법(infix notation): e.g.) 5 + 2 / 7
- 전위 표기법(prefix notation): e.g.) + 5 / 2 7
- 후위 표기법(postfix notation): e.g.) 5 2 7 / +
이 중 전위 표기법과 후위 표기법은 배치순서를 근거로 한 연산순서의 정보가 담겨있음(연산자의 배치순서를 바꿈으로써 연산의 순서를 바꿀 수 있기 때문에, 소괄호를 필요로 하지 않음). <br><br>

구현할 계산기는 다음의 과정을 거침. <br>
- 중위 표기법의 수식을 후위 표기법으로 바꿈
- 후위 표기법의 수식을 계산하여 결과를 얻음 <br><br>

우선 중위 표기법 -> 후위 표기법 변환 방법은 다음과 같음.
- 수식의 앞쪽부터 차례대로 시작
- 피연산자(숫자)는 그냥 옮김
- 연산자는 쟁반으로 옮김
- 쟁반에 위치한 연산자들의 우선순위가 높거나 같으면, 쟁반의 연산자들을 모두 꺼내고 새 연산자를 쟁반으로 옮김 / 그렇지 않으면, 쟁반의 연산자들 위에 새 연산자를 쌓음
- 괄호 연산자는 반대쪽 괄호가 등장할 때까지 쟁반에 남아있다가 괄호 연산자 사이의 연산자들만 하나씩 꺼냄(괄호는 버림)
- 마지막까지 쟁반에 남아있는 연산자들을 하나씩 꺼냄

![Fig. 1](images/2022-11-01-1.PNG) <br>
![Fig. 2](images/2022-11-01-2.PNG) <center>Fig 1: 중위 표기법 -> 후위 표기법 변환 </center> <br>



[`Top`](#top)
